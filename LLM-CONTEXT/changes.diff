diff --git a/LLM-CONTEXT/categorized_files.txt b/LLM-CONTEXT/categorized_files.txt
new file mode 100644
index 0000000..08ccb6e
--- /dev/null
+++ b/LLM-CONTEXT/categorized_files.txt
@@ -0,0 +1,49 @@
+OTHER: 
+OTHER: 
+OTHER: 
+OTHER: 
+OTHER: 
+OTHER: 
+OTHER: 
+OTHER: 
+OTHER: 
+OTHER: 
+OTHER: 
+OTHER: 
+OTHER: 
+OTHER: 
+OTHER: 
+OTHER: 
+OTHER: 
+OTHER: 
+OTHER: 
+OTHER: 
+OTHER: 
+OTHER: 
+OTHER: 
+OTHER: 
+OTHER: 
+OTHER: 
+OTHER: 
+OTHER: 
+OTHER: 
+OTHER: 
+OTHER: 
+OTHER: 
+OTHER: 
+OTHER: 
+OTHER: 
+OTHER: 
+OTHER: 
+OTHER: 
+OTHER: 
+OTHER: 
+OTHER: 
+OTHER: 
+OTHER: 
+OTHER: 
+OTHER: 
+OTHER: 
+OTHER: 
+OTHER: 
+OTHER: 
diff --git a/LLM-CONTEXT/changes.diff b/LLM-CONTEXT/changes.diff
new file mode 100644
index 0000000..e69de29
diff --git a/LLM-CONTEXT/files_to_review.txt b/LLM-CONTEXT/files_to_review.txt
new file mode 100644
index 0000000..6a23f63
--- /dev/null
+++ b/LLM-CONTEXT/files_to_review.txt
@@ -0,0 +1,49 @@
+=== MODIFIED FILES (staged + unstaged) ===
+LLM-CONTEXT/categorized_files.txt
+LLM-CONTEXT/changes.diff
+LLM-CONTEXT/files_to_review.txt
+LLM-CONTEXT/prioritized_review_plan.txt
+README.md
+src/lib_log_rich/__init__.py
+src/lib_log_rich/adapters/_formatting.py
+src/lib_log_rich/adapters/_queue_worker.py
+src/lib_log_rich/adapters/dump.py
+src/lib_log_rich/adapters/queue.py
+src/lib_log_rich/adapters/rate_limiter.py
+src/lib_log_rich/cli.py
+src/lib_log_rich/domain/ring_buffer.py
+src/lib_log_rich/lib_log_rich.py
+src/lib_log_rich/runtime/__init__.py
+src/lib_log_rich/runtime/_composition.py
+src/lib_log_rich/runtime/_factories.py
+src/lib_log_rich/runtime/_state.py
+src/lib_log_rich/runtime/settings/models.py
+test-write
+test-write2
+tests/runtime/test_runtime_state.py
+
+=== UNTRACKED FILES ===
+
+=== DETAILED STATUS ===
+AM LLM-CONTEXT/categorized_files.txt
+AM LLM-CONTEXT/changes.diff
+AM LLM-CONTEXT/files_to_review.txt
+AM LLM-CONTEXT/prioritized_review_plan.txt
+ M README.md
+ M src/lib_log_rich/__init__.py
+ M src/lib_log_rich/adapters/_formatting.py
+ M src/lib_log_rich/adapters/_queue_worker.py
+ M src/lib_log_rich/adapters/dump.py
+ M src/lib_log_rich/adapters/queue.py
+ M src/lib_log_rich/adapters/rate_limiter.py
+ M src/lib_log_rich/cli.py
+ M src/lib_log_rich/domain/ring_buffer.py
+ M src/lib_log_rich/lib_log_rich.py
+ M src/lib_log_rich/runtime/__init__.py
+ M src/lib_log_rich/runtime/_composition.py
+ M src/lib_log_rich/runtime/_factories.py
+ M src/lib_log_rich/runtime/_state.py
+ M src/lib_log_rich/runtime/settings/models.py
+A  test-write
+A  test-write2
+ M tests/runtime/test_runtime_state.py
diff --git a/LLM-CONTEXT/prioritized_review_plan.txt b/LLM-CONTEXT/prioritized_review_plan.txt
new file mode 100644
index 0000000..e69de29
diff --git a/README.md b/README.md
index dd135e1..63be0b0 100644
--- a/README.md
+++ b/README.md
@@ -77,7 +77,7 @@ The public API stays intentionally small: initialise once, bind context, emit lo
 - supports quick log-dump with filtering from the ringbuffer without leaving the application
 - runtime configuration validated via Pydantic models, yielding structured errors and JSON schemas
 - per-event payload guards (4KB messages, 8KB extras, depth limits) configurable via `payload_limits`
-- backend level governs journald / Event Log adapters, while `graylog_level` can be higher to further trim Graylog traffic
+- **independent log levels**: `console_level`, `backend_level`, and `graylog_level` are completely independent — each gates events to its respective adapter (console, journald/EventLog, Graylog) without affecting the others. Use `get_minimum_log_level()` to find the lowest threshold for stdlib integration.
 - opt-in `.env` loading (same precedence for CLI and programmatic use)
 - Open Telemetry Support on user (Your) request - not implemented yet (because I do not need it myself). If You need it, let me know.
 - optional `diagnostic_hook` callback that observes the runtime without modifying it. The hook reports queue activity (drops, worker failures, drop-handler errors), rate limiting, and payload clamps so you can surface metrics, alerts, or dashboards while keeping the logging pipeline decoupled from any monitoring stack.
@@ -444,6 +444,41 @@ if __name__ == "__main__":
 - Location metadata (`pathname`, `lineno`, `funcName`, plus any custom `extra` fields) is copied into the event so dumps, Graylog, and Rich console output can display the original call site.
 - Records originating from `lib_log_rich` are ignored automatically to avoid recursion; set `extra={"lib_log_rich_skip": True}` if you need to suppress specific third-party records.
 
+#### Setting stdlib root logger level with `get_minimum_log_level()`
+
+When integrating with stdlib logging, you often want to ensure the stdlib root logger doesn't pre-filter events before they reach lib_log_rich. Use `get_minimum_log_level()` to automatically match the most permissive threshold:
+
+```python
+import logging
+import lib_log_rich as log
+
+# Initialize with independent levels for different adapters
+config = log.RuntimeConfig(
+    service="my-service",
+    environment="prod",
+    console_level="INFO",      # Console shows INFO and above
+    backend_level="WARNING",   # Journald/EventLog shows WARNING and above
+    graylog_level="ERROR",     # Graylog shows ERROR and above
+    enable_graylog=True,
+)
+log.init(config)
+
+# Set stdlib root logger to the minimum level (INFO in this example)
+# This ensures stdlib doesn't filter out INFO events before they reach lib_log_rich
+logging.getLogger().setLevel(log.get_minimum_log_level().to_python_level())
+
+# Now stdlib loggers won't pre-filter
+logging.getLogger("app.module").info("This reaches lib_log_rich console")
+logging.getLogger("app.module").debug("This is filtered by lib_log_rich, not stdlib")
+
+log.shutdown()
+```
+
+Key points:
+- **Independent levels**: `console_level`, `backend_level`, and `graylog_level` are completely independent. Each gates events to its respective adapter without affecting the others.
+- **`get_minimum_log_level()`**: Returns the lowest (most permissive) threshold among active adapters. When Graylog is disabled, its level is ignored.
+- **Stdlib integration**: Setting the stdlib root logger to the minimum level ensures lib_log_rich receives all events that might reach any adapter, while each adapter independently decides whether to emit.
+
 ---
 
 
@@ -461,7 +496,8 @@ All runtime configuration flows through `RuntimeConfig`. Create an instance with
 | `getLogger`                | `getLogger(name: str) -> LoggerProxy`                                                                                                                                                                                                                               | Returns a `LoggerProxy` exposing `.debug/.info/.warning/.error/.critical/.exception`. Each call returns a dict (e.g. `{"ok": True, "event_id": "..."}` or `{ "ok": False, "reason": "rate_limited" }`).                                                                                                                                                                                                         |
 | `LoggerProxy`              | created via `getLogger(name)`                                                                                                                                                                                                                                       | Lightweight facade around the process use case. Level helpers mirror the stdlib signature: `.debug(msg, *args, exc_info=None, stack_info=None, stacklevel=1, extra=None)` (and similarly for `info`/`warning`/`error`/`critical`) plus `.exception(msg, *args, exc_info=True, ...)`, `.log(level, msg, *args, ...)`, and `.setLevel(level)`. Messages are formatted in the pipeline, `exc_info`/`stack_info` payloads are preserved for adapters, and `stacklevel` is accepted but ignored. `.setLevel(...)` updates the proxy's own threshold so events must satisfy it *and* the handler levels; calls still return the diagnostic dict (unlike `logging.Logger`, which returns `None`). |
 | `dump`                     | `dump(*, dump_format="text", path=None, level=None, console_format_preset=None, console_format_template=None, theme=None, console_styles=None, context_filters=None, context_extra_filters=None, extra_filters=None, color=False) -> str`                           | Serialises the ring buffer (text/json/html_table/html_txt). `level` filters events by severity, presets/templates customise text rendering (template wins), `theme`/`console_styles` reuse or override the runtime palette, the `context_*`/`extra_*` filter mappings narrow results by metadata, and `color` toggles ANSI output for text dumps. Payloads are always returned and optionally written to `path`. |
-| `max_level_seen`           | `max_level_seen() -> LogLevel                                                                                                                                                                                                                                       | None`                                                                                                                                                                                                                                                                                                                                                                                                            | Returns the highest severity observed since the runtime was initialised or metrics were reset. Handy for “only dump logs when something ≥ ERROR happened” checks. |
+| `get_minimum_log_level`    | `get_minimum_log_level() -> LogLevel`                                                                                                                                                                                                                              | Returns the minimum (most permissive) log level among all active adapters (`console_level`, `backend_level`, and `graylog_level` when Graylog is enabled). Useful for setting the stdlib `logging.Logger` root level to match the lowest threshold, ensuring no events are pre-filtered before reaching lib_log_rich. Raises `RuntimeError` if called before `init()`.                                           |
+| `max_level_seen`           | `max_level_seen() -> LogLevel                                                                                                                                                                                                                                       | None`                                                                                                                                                                                                                                                                                                                                                                                                            | Returns the highest severity observed since the runtime was initialised or metrics were reset. Handy for "only dump logs when something ≥ ERROR happened" checks. |
 | `severity_snapshot`        | `severity_snapshot() -> SeveritySnapshot`                                                                                                                                                                                                                           | Captures totals, per-level counts, threshold buckets, and drop statistics (by reason and severity). Safe to call from any thread.                                                                                                                                                                                                                                                                                |
 | `reset_severity_metrics`   | `reset_severity_metrics() -> None`                                                                                                                                                                                                                                  | Clears severity and drop counters without touching the ring buffer or adapters. Invoke after you’ve handed dumps to operators.                                                                                                                                                                                                                                                                                   |
 | `shutdown`                 | `shutdown() -> None`                                                                                                                                                                                                                                                | Flushes adapters, drains/stops the queue, and clears global state. Safe to call repeatedly after initialisation.                                                                                                                                                                                                                                                                                                 |
@@ -537,12 +573,12 @@ The optional backend flags (`enable_graylog`, `enable_journald`, `enable_eventlo
 |---------------------------------|------------------------------------------------------|-----------------------------------------------------|--------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------|------------------------------------------------------|
 | `service`                       | `str`                                                | *(required)*                                        | Non-empty identifier such as `checkout`, `worker`, `billing`.                                    | Logical service name recorded in each event and used by adapters.                   | `LOG_SERVICE`                                        |
 | `environment`                   | `str`                                                | *(required)*                                        | Deployment label (`dev`, `stage`, `prod`, `local`, ...)                                          | Deployment environment recorded in each event and used by adapters.                 | `LOG_ENVIRONMENT`                                    |
-| `console_level`                 | `str \| LogLevel`                                    | `LogLevel.INFO`                                     | Case-insensitive `debug`, `info`, `warning`, `error`, `critical` or a `LogLevel` enum.           | Lowest level emitted to the Rich console adapter.                                   | `LOG_CONSOLE_LEVEL`                                  |
-| `backend_level`                 | `str \| LogLevel`                                    | `LogLevel.WARNING`                                  | Same set as `console_level`.                                                                     | Threshold shared by journald and Windows Event Log adapters.                        | `LOG_BACKEND_LEVEL`                                  |
+| `console_level`                 | `str \| LogLevel`                                    | `LogLevel.INFO`                                     | Case-insensitive `debug`, `info`, `warning`, `error`, `critical` or a `LogLevel` enum.           | Lowest level emitted to the Rich console adapter. **Independent** of backend/Graylog levels. | `LOG_CONSOLE_LEVEL`                                  |
+| `backend_level`                 | `str \| LogLevel`                                    | `LogLevel.WARNING`                                  | Same set as `console_level`.                                                                     | Threshold shared by journald and Windows Event Log adapters. **Independent** of console/Graylog levels. | `LOG_BACKEND_LEVEL`                                  |
 | `graylog_endpoint`              | `tuple[str, int] \| None`                            | `None`                                              | `(host, port)` tuple or `HOST:PORT` string (port > 0).                                           | Host/port for GELF; combine with `enable_graylog=True`.                             | `LOG_GRAYLOG_ENDPOINT` (`host:port`)                 |
 | `graylog_protocol`              | `str`                                                | `"tcp"`                                             | Literal `tcp` or `udp` (case-insensitive).                                                       | Transport to reach Graylog.                                                         | `LOG_GRAYLOG_PROTOCOL`                               |
 | `graylog_tls`                   | `bool`                                               | `False`                                             | `True` only when `graylog_protocol="tcp"`.                                                       | Wrap the Graylog connection in TLS.                                                 | `LOG_GRAYLOG_TLS`                                    |
-| `graylog_level`                 | `str \| LogLevel`                                    | `LogLevel.WARNING`                                  | Same set as `console_level`.                                                                     | Severity threshold for Graylog fan-out.                                             | `LOG_GRAYLOG_LEVEL`                                  |
+| `graylog_level`                 | `str \| LogLevel`                                    | `LogLevel.WARNING`                                  | Same set as `console_level`.                                                                     | Severity threshold for Graylog fan-out. **Independent** of console/backend levels. Use `get_minimum_log_level()` to find the lowest among all three. | `LOG_GRAYLOG_LEVEL`                                  |
 | `enable_ring_buffer`            | `bool`                                               | `True`                                              | `True`/`False`.                                                                                  | Toggles the in-memory ring buffer (falls back to 1024 events when disabled).        | `LOG_RING_BUFFER_ENABLED`                            |
 | `ring_buffer_size`              | `int`                                                | `25_000`                                            | Integer > 0 (events).                                                                            | Max events retained in the ring buffer.                                             | `LOG_RING_BUFFER_SIZE`                               |
 | `enable_journald`               | `bool`                                               | `False`                                             | `True`/`False`; effective on Linux/systemd only.                                                 | Adds the journald adapter.                                                          | `LOG_ENABLE_JOURNALD`                                |
diff --git a/src/lib_log_rich/__init__.py b/src/lib_log_rich/__init__.py
index d75f878..7450cf3 100644
--- a/src/lib_log_rich/__init__.py
+++ b/src/lib_log_rich/__init__.py
@@ -28,6 +28,7 @@ from .lib_log_rich import (
     bind,
     dump,
     getLogger,
+    get_minimum_log_level,
     hello_world,
     i_should_fail,
     init,
@@ -46,6 +47,7 @@ __all__ = [
     "bind",
     "dump",
     "getLogger",
+    "get_minimum_log_level",
     "hello_world",
     "i_should_fail",
     "init",
diff --git a/src/lib_log_rich/adapters/_formatting.py b/src/lib_log_rich/adapters/_formatting.py
index eccf7d3..ed657b2 100644
--- a/src/lib_log_rich/adapters/_formatting.py
+++ b/src/lib_log_rich/adapters/_formatting.py
@@ -94,14 +94,19 @@ def build_format_payload(event: LogEvent) -> dict[str, Any]:
     ('INFO', 'svc')
     """
 
+    # Extract context and extra as dictionaries for field lookup
     context_dict = event.context.to_dict(include_none=True)
     extra_dict = dict(event.extra)
 
+    # Build context_fields string: merge context+extra, filter None/{}, sort, format as "k=v k2=v2"
+    # This produces the compact key=value representation used in console output
     merged_pairs = {key: value for key, value in {**context_dict, **extra_dict}.items() if value not in (None, {})}
     context_fields = ""
     if merged_pairs:
         context_fields = " " + " ".join(f"{key}={value}" for key, value in sorted(merged_pairs.items()))
 
+    # Normalize process_id_chain: convert list/tuple to formatted string for templates
+    # Example: [100, 200, 300] becomes "100>200>300"
     chain_raw = context_dict.get("process_id_chain")
     formatted_chain: ChainInput
     if isinstance(chain_raw, (list, tuple)):
@@ -112,14 +117,18 @@ def build_format_payload(event: LogEvent) -> dict[str, Any]:
     else:
         formatted_chain = str(chain_raw)
 
+    # Prepare level text and timestamp variants
     level_text = event.level.severity.upper()
     timestamp = event.timestamp
+    # Trimmed = no microseconds, for cleaner display in logs
     trimmed_timestamp = timestamp.replace(microsecond=0)
 
+    # Local timezone variants for user-friendly display
     local_timestamp = event.timestamp.astimezone()
     trimmed_local = local_timestamp.replace(microsecond=0)
     trimmed_local_naive = trimmed_local.replace(tzinfo=None)
 
+    # Naive UTC variant (no timezone info, for legacy templates)
     trimmed_naive = trimmed_timestamp.replace(tzinfo=None)
 
     payload: dict[str, Any] = {
diff --git a/src/lib_log_rich/adapters/_queue_worker.py b/src/lib_log_rich/adapters/_queue_worker.py
index 9d07c43..6ead8a0 100644
--- a/src/lib_log_rich/adapters/_queue_worker.py
+++ b/src/lib_log_rich/adapters/_queue_worker.py
@@ -1,4 +1,47 @@
-"""Internal worker state for the queue adapter."""
+"""Internal worker state for the queue adapter.
+
+Thread-Safe Queue Worker Implementation
+=======================================
+
+This module implements a background worker thread that processes log events
+from a queue. The worker handles graceful shutdown, backpressure, and failure
+recovery.
+
+Algorithm
+---------
+The worker uses a two-phase shutdown protocol:
+
+1. GRACEFUL: Stop accepting new items, drain existing items (timeout: configurable)
+2. FORCED: Abort after timeout, dropping remaining items
+
+Backpressure Handling
+--------------------
+When queue reaches capacity, behavior depends on drop_policy:
+
+- "drop_oldest": Remove oldest item to make room (default)
+- "drop_newest": Reject new item
+- "block": Wait for space (not recommended in async contexts)
+
+Items dropped trigger diagnostic callbacks with reason codes:
+- "queue_full": Queue at capacity
+- "worker_failure": Worker thread crashed
+- "shutdown": Dropped during shutdown
+
+Worker enters degraded mode after failures and recovers after successful batch.
+
+Thread Safety
+------------
+All public methods are thread-safe via internal RLock. The queue itself
+provides thread-safe put/get operations. Worker thread has exclusive access
+to internal state during event processing.
+
+Performance Characteristics
+--------------------------
+- Queue operations: O(1)
+- Shutdown drain: O(n) where n = queue size
+- Memory: O(maxsize * avg_event_size)
+- Typical event processing: <1ms per event
+"""
 
 from __future__ import annotations
 
diff --git a/src/lib_log_rich/adapters/dump.py b/src/lib_log_rich/adapters/dump.py
index 04775c9..b5c5edc 100644
--- a/src/lib_log_rich/adapters/dump.py
+++ b/src/lib_log_rich/adapters/dump.py
@@ -70,6 +70,113 @@ def _load_console_themes() -> dict[str, dict[str, str]]:
     return {name.lower(): {level.upper(): style for level, style in palette.items()} for name, palette in CONSOLE_STYLE_THEMES.items()}
 
 
+def _create_rich_console_for_dump() -> Console:
+    """Create Rich console configured for dump rendering with truecolor support."""
+    return Console(color_system="truecolor", force_terminal=True, legacy_windows=False)
+
+
+def _create_style_wrapper(rich_console: Console, style: str) -> tuple[str, str]:
+    """Generate ANSI prefix/suffix pair for a given Rich style string.
+
+    Parameters
+    ----------
+    rich_console:
+        Rich console instance for rendering.
+    style:
+        Rich style string to convert.
+
+    Returns
+    -------
+    tuple[str, str]
+        (prefix, suffix) ANSI sequences to wrap text.
+    """
+    marker = "\u0000"
+    with rich_console.capture() as capture:
+        rich_console.print(Text(marker, style=style), end="")
+    styled_marker = capture.get()
+    prefix, marker_found, suffix = styled_marker.partition(marker)
+    if not marker_found:
+        return ("", "")
+    return (prefix, suffix)
+
+
+def _resolve_event_style(
+    event: LogEvent,
+    *,
+    resolved_styles: dict[str, str],
+    theme_styles: dict[str, str],
+) -> str | None:
+    """Determine the Rich style string for an event based on level and theme.
+
+    Parameters
+    ----------
+    event:
+        Log event to style.
+    resolved_styles:
+        Explicit style overrides keyed by level name.
+    theme_styles:
+        Theme palette keyed by level name.
+
+    Returns
+    -------
+    str | None:
+        Rich style string, or None if no style found.
+    """
+    # Check explicit style overrides first
+    style_name = resolved_styles.get(event.level.name)
+    if style_name is not None:
+        return style_name
+
+    # Check event-specific theme override
+    event_theme = None
+    try:
+        event_theme = event.extra.get("theme")
+    except AttributeError:
+        event_theme = None
+
+    # Resolve palette (event theme > default theme)
+    if isinstance(event_theme, str):
+        palette = _resolve_theme_styles(event_theme) or theme_styles
+    else:
+        palette = theme_styles
+
+    # Lookup level in palette
+    if palette:
+        return palette.get(event.level.name)
+
+    return None
+
+
+def _apply_fallback_ansi_color(line: str, level: LogLevel) -> str:
+    """Apply simple ANSI color to line based on log level.
+
+    Parameters
+    ----------
+    line:
+        Text line to colorize.
+    level:
+        Log level determining color choice.
+
+    Returns
+    -------
+    str:
+        Line wrapped in ANSI color codes if level has a fallback color.
+    """
+    fallback_colours = {
+        LogLevel.DEBUG: "\u001b[36m",  # cyan
+        LogLevel.INFO: "\u001b[32m",  # green
+        LogLevel.WARNING: "\u001b[33m",  # yellow
+        LogLevel.ERROR: "\u001b[31m",  # red
+        LogLevel.CRITICAL: "\u001b[35m",  # magenta
+    }
+    reset = "\u001b[0m"
+
+    colour = fallback_colours.get(level)
+    if colour:
+        return f"{colour}{line}{reset}"
+    return line
+
+
 def _normalise_styles(styles: Mapping[str, str] | None) -> dict[str, str]:
     """Convert mixed keys to uppercase level names for palette lookups.
 
@@ -321,45 +428,32 @@ class DumpAdapter(DumpPort):
         if not events:
             return ""
 
+        # Prepare template and style configuration
         pattern = template or "{timestamp} {LEVEL:<8} {logger_name} {event_id} {message}"
-
-        fallback_colours = {
-            LogLevel.DEBUG: "\u001b[36m",  # cyan
-            LogLevel.INFO: "\u001b[32m",  # green
-            LogLevel.WARNING: "\u001b[33m",  # yellow
-            LogLevel.ERROR: "\u001b[31m",  # red
-            LogLevel.CRITICAL: "\u001b[35m",  # magenta
-        }
-        reset = "\u001b[0m"
-
         resolved_styles = _normalise_styles(console_styles)
         theme_styles = _resolve_theme_styles(theme)
 
+        # Initialize Rich console for colorization if needed
         rich_console: Console | None = None
         style_wrappers: dict[str, tuple[str, str]] = {}
         if colorize:
-            rich_console = Console(color_system="truecolor", force_terminal=True, legacy_windows=False)
+            rich_console = _create_rich_console_for_dump()
 
         def _wrap_line(style: str, line_text: str) -> str:
+            """Apply Rich style to line text using cached ANSI wrappers."""
             if rich_console is None:
                 raise RuntimeError("Rich console must be initialised when colorize is enabled.")
+            # Cache wrapper to avoid regenerating ANSI sequences
             wrapper = style_wrappers.get(style)
             if wrapper is None:
-                marker = "\u0000"
-                with rich_console.capture() as capture:
-                    rich_console.print(Text(marker, style=style), end="")
-                styled_marker = capture.get()
-                prefix, marker_found, suffix = styled_marker.partition(marker)
-                if not marker_found:
-                    wrapper = ("", "")
-                else:
-                    wrapper = (prefix, suffix)
+                wrapper = _create_style_wrapper(rich_console, style)
                 style_wrappers[style] = wrapper
             start, end = wrapper
             if not start and not end:
                 return line_text
             return f"{start}{line_text}{end}"
 
+        # Render each event as a formatted line
         lines: list[str] = []
         for event in events:
             data = build_format_payload(event)
@@ -370,30 +464,21 @@ class DumpAdapter(DumpPort):
             except ValueError as exc:  # pragma: no cover - invalid specifier
                 raise ValueError(f"Invalid format specification in template: {exc}") from exc
 
+            # Apply colorization if requested
             if colorize and rich_console is not None:
-                style_name: str | None = resolved_styles.get(event.level.name)
-
-                if style_name is None:
-                    event_theme = None
-                    try:
-                        event_theme = event.extra.get("theme")
-                    except AttributeError:
-                        event_theme = None
-                    if isinstance(event_theme, str):
-                        palette = _resolve_theme_styles(event_theme) or theme_styles
-                    else:
-                        palette = theme_styles
-                    if palette:
-                        style_name = palette.get(event.level.name)
-
+                # Resolve style from overrides/theme
+                style_name = _resolve_event_style(
+                    event,
+                    resolved_styles=resolved_styles,
+                    theme_styles=theme_styles,
+                )
+
+                # Apply Rich style if found
                 if style_name:
-                    styled_line = _wrap_line(style_name, line)
-                    lines.append(styled_line)
-                    continue
-
-                colour = fallback_colours.get(event.level)
-                if colour:
-                    line = f"{colour}{line}{reset}"
+                    line = _wrap_line(style_name, line)
+                else:
+                    # Fallback to simple ANSI colors
+                    line = _apply_fallback_ansi_color(line, event.level)
 
             lines.append(line)
         return "\n".join(lines)
diff --git a/src/lib_log_rich/adapters/queue.py b/src/lib_log_rich/adapters/queue.py
index 2114e3b..a0c3342 100644
--- a/src/lib_log_rich/adapters/queue.py
+++ b/src/lib_log_rich/adapters/queue.py
@@ -26,6 +26,7 @@ from typing import Any, ClassVar, Optional
 
 from lib_log_rich.application.ports.queue import QueuePort
 from lib_log_rich.domain.events import LogEvent
+from lib_log_rich.runtime.settings.models import DEFAULT_QUEUE_MAXSIZE, DEFAULT_QUEUE_PUT_TIMEOUT, DEFAULT_QUEUE_STOP_TIMEOUT
 
 from ._queue_worker import QueueWorkerState
 
@@ -55,11 +56,11 @@ class QueueAdapter(QueuePort):
         self,
         *,
         worker: Callable[[LogEvent], None] | None = None,
-        maxsize: int = 2048,
+        maxsize: int = DEFAULT_QUEUE_MAXSIZE,
         drop_policy: str = "block",
         on_drop: Callable[[LogEvent], None] | None = None,
-        timeout: float | None = 1.0,
-        stop_timeout: float | None = 5.0,
+        timeout: float | None = DEFAULT_QUEUE_PUT_TIMEOUT,
+        stop_timeout: float | None = DEFAULT_QUEUE_STOP_TIMEOUT,
         diagnostic: Callable[[str, dict[str, Any]], None] | None = None,
         failure_reset_after: float | None = 30.0,
     ) -> None:
diff --git a/src/lib_log_rich/adapters/rate_limiter.py b/src/lib_log_rich/adapters/rate_limiter.py
index 25b01ea..eae523a 100644
--- a/src/lib_log_rich/adapters/rate_limiter.py
+++ b/src/lib_log_rich/adapters/rate_limiter.py
@@ -66,15 +66,40 @@ class SlidingWindowRateLimiter(RateLimiterPort):
         self._buckets: Dict[Tuple[str, str], Deque[float]] = defaultdict(deque)
 
     def allow(self, event: LogEvent) -> bool:
-        """Return ``True`` when ``event`` is within the configured quota."""
+        """Return ``True`` when ``event`` is within the configured quota.
+
+        Algorithm
+        ---------
+        Implements sliding window rate limiting per (logger_name, severity) bucket:
+        1. Retrieve or create a deque of timestamps for this bucket
+        2. Remove all timestamps older than the current window
+        3. Check if bucket has capacity for one more event
+        4. If yes, record this event's timestamp and allow it
+        5. If no, reject the event (rate limit exceeded)
+
+        Thread Safety
+        -------------
+        NOT thread-safe. Caller must ensure exclusive access if used across threads.
+        """
+        # Use (logger_name, severity) as bucket key to track quotas independently
+        # per logger/level combination (e.g., "app.worker" at ERROR vs DEBUG)
         key = (event.logger_name, event.level.severity)
         bucket = self._buckets[key]
+
+        # Calculate the sliding window: all events within [cutoff, now] are counted
         now = event.timestamp.timestamp()
         cutoff = now - self._interval.total_seconds()
+
+        # Evict expired timestamps from left (oldest) side of deque
+        # This maintains the sliding window by removing events outside the interval
         while bucket and bucket[0] <= cutoff:
             bucket.popleft()
+
+        # Reject if we've already hit the quota within this window
         if len(bucket) >= self._max_events:
             return False
+
+        # Accept the event and record its timestamp for future checks
         bucket.append(now)
         return True
 
diff --git a/src/lib_log_rich/cli.py b/src/lib_log_rich/cli.py
index d63bb7c..0ea9777 100644
--- a/src/lib_log_rich/cli.py
+++ b/src/lib_log_rich/cli.py
@@ -30,7 +30,7 @@ import os
 import re
 from pathlib import Path
 from contextlib import AbstractContextManager
-from typing import Callable, Final, Mapping, Optional, Sequence, cast
+from typing import Any, Callable, Final, Mapping, Optional, Sequence, cast
 
 import lib_cli_exit_tools
 import rich_click as click
@@ -237,6 +237,224 @@ def _parse_graylog_endpoint(value: str | None) -> tuple[str, int] | None:
     return host, int(port)
 
 
+def _build_dump_filters(
+    *,
+    context_exact: tuple[str, ...],
+    context_contains: tuple[str, ...],
+    context_icontains: tuple[str, ...],
+    context_regex: tuple[str, ...],
+    context_extra_exact: tuple[str, ...],
+    context_extra_contains: tuple[str, ...],
+    context_extra_icontains: tuple[str, ...],
+    context_extra_regex: tuple[str, ...],
+    extra_exact: tuple[str, ...],
+    extra_contains: tuple[str, ...],
+    extra_icontains: tuple[str, ...],
+    extra_regex: tuple[str, ...],
+) -> tuple[FilterMapping | None, FilterMapping | None, FilterMapping | None]:
+    """Build filter mappings from CLI options for context, context_extra, and extra fields.
+
+    Parameters
+    ----------
+    context_*, context_extra_*, extra_*:
+        Filter option tuples from CLI arguments.
+
+    Returns
+    -------
+    tuple[FilterMapping | None, FilterMapping | None, FilterMapping | None]
+        Triple of (context_filters, context_extra_filters, extra_filters).
+    """
+    context_filters = _none_if_empty(
+        _collect_field_filters(
+            option_prefix="--context",
+            exact=context_exact,
+            contains=context_contains,
+            icontains=context_icontains,
+            regex=context_regex,
+        ),
+    )
+    context_extra_filters = _none_if_empty(
+        _collect_field_filters(
+            option_prefix="--context-extra",
+            exact=context_extra_exact,
+            contains=context_extra_contains,
+            icontains=context_extra_icontains,
+            regex=context_extra_regex,
+        ),
+    )
+    extra_filters = _none_if_empty(
+        _collect_field_filters(
+            option_prefix="--extra",
+            exact=extra_exact,
+            contains=extra_contains,
+            icontains=extra_icontains,
+            regex=extra_regex,
+        ),
+    )
+    return context_filters, context_extra_filters, extra_filters
+
+
+def _resolve_format_presets(
+    ctx: click.Context,
+    console_format_preset: str | None,
+    console_format_template: str | None,
+) -> tuple[str | None, str | None]:
+    """Resolve console format preset and template from CLI args and context inheritance.
+
+    Parameters
+    ----------
+    ctx:
+        Click context containing inherited values.
+    console_format_preset:
+        Explicit preset from CLI argument.
+    console_format_template:
+        Explicit template from CLI argument.
+
+    Returns
+    -------
+    tuple[str | None, str | None]
+        Resolved (preset, template) pair, preferring explicit args over inheritance.
+    """
+    inherited_preset = ctx.obj.get("console_format_preset") if ctx.obj else None
+    inherited_template = ctx.obj.get("console_format_template") if ctx.obj else None
+
+    if console_format_preset is None:
+        console_format_preset = inherited_preset
+    if console_format_template is None:
+        console_format_template = inherited_template
+
+    return console_format_preset, console_format_template
+
+
+def _print_theme_styles(theme_name: str, styles: dict[str, str]) -> None:
+    """Print theme header and style mappings to console.
+
+    Parameters
+    ----------
+    theme_name:
+        Name of the theme being displayed.
+    styles:
+        Level->style mapping for this theme.
+    """
+    click.echo(click.style(f"=== Theme: {theme_name} ===", bold=True))
+    for level, style in styles.items():
+        click.echo(f"  {level:<8} -> {style}")
+    click.echo("  emitting sample events…")
+
+
+def _print_backend_status(
+    *,
+    enable_graylog: bool,
+    enable_journald: bool,
+    enable_eventlog: bool,
+    endpoint_tuple: tuple[str, int] | None,
+    graylog_protocol: str,
+    graylog_tls: bool,
+) -> None:
+    """Print status of enabled backend adapters.
+
+    Parameters
+    ----------
+    enable_graylog:
+        Whether Graylog adapter is enabled.
+    enable_journald:
+        Whether journald adapter is enabled.
+    enable_eventlog:
+        Whether Windows Event Log adapter is enabled.
+    endpoint_tuple:
+        Graylog (host, port) if configured.
+    graylog_protocol:
+        Graylog protocol ('tcp' or 'udp').
+    graylog_tls:
+        Whether TLS is enabled for Graylog.
+    """
+    if enable_graylog:
+        destination = endpoint_tuple or ("127.0.0.1", 12201)
+        scheme = graylog_protocol.upper() + ("+TLS" if graylog_tls and graylog_protocol == "tcp" else "")
+        click.echo(f"  graylog -> {destination[0]}:{destination[1]} via {scheme}")
+    if enable_journald:
+        click.echo("  journald -> systemd.journal.send")
+    if enable_eventlog:
+        click.echo("  eventlog -> Windows Event Log")
+
+
+def _run_theme_demo(
+    *,
+    theme_name: str,
+    service: str,
+    environment: str,
+    dump_format: str | None,
+    target_path: Path | None,
+    console_format_preset: str | None,
+    console_format_template: str | None,
+    dump_format_preset: str | None,
+    dump_format_template: str | None,
+    enable_graylog: bool,
+    graylog_endpoint: tuple[str, int] | None,
+    graylog_protocol: str,
+    graylog_tls: bool,
+    enable_journald: bool,
+    enable_eventlog: bool,
+    context_filters: FilterMapping | None,
+    context_extra_filters: FilterMapping | None,
+    extra_filters: FilterMapping | None,
+) -> dict[str, Any]:
+    """Execute logdemo for a single theme and return results.
+
+    Parameters
+    ----------
+    theme_name:
+        Theme to use for this demo run.
+    service, environment:
+        Metadata fields for log context.
+    dump_format, target_path:
+        Optional dump configuration.
+    console_format_preset, console_format_template:
+        Console output formatting.
+    dump_format_preset, dump_format_template:
+        Dump output formatting.
+    enable_graylog, graylog_endpoint, graylog_protocol, graylog_tls:
+        Graylog adapter configuration.
+    enable_journald, enable_eventlog:
+        Platform adapter toggles.
+    context_filters, context_extra_filters, extra_filters:
+        Filter mappings for dump output.
+
+    Returns
+    -------
+    dict[str, Any]
+        Result dictionary from _logdemo containing 'events' and optional 'dump'.
+
+    Raises
+    ------
+    click.ClickException:
+        If _logdemo raises ValueError.
+    """
+    try:
+        return _logdemo(
+            theme=theme_name,
+            service=service,
+            environment=f"{environment}-{theme_name}" if environment else None,
+            dump_format=dump_format,
+            dump_path=target_path,
+            console_format_preset=console_format_preset,
+            console_format_template=console_format_template,
+            dump_format_preset=dump_format_preset,
+            dump_format_template=dump_format_template,
+            enable_graylog=enable_graylog,
+            graylog_endpoint=graylog_endpoint,
+            graylog_protocol=graylog_protocol,
+            graylog_tls=graylog_tls,
+            enable_journald=enable_journald,
+            enable_eventlog=enable_eventlog,
+            context_filters=context_filters,
+            context_extra_filters=context_extra_filters,
+            extra_filters=extra_filters,
+        )
+    except ValueError as exc:
+        raise click.ClickException(str(exc)) from exc
+
+
 @click.group(
     help=__init__conf__.title,
     context_settings=CLICK_CONTEXT_SETTINGS,
@@ -545,103 +763,89 @@ def cli_logdemo(
     Prints diagnostic information, may create dump files, and may emit events to
     external logging systems depending on the flags.
     """
-
-    context_filters_map = _none_if_empty(
-        _collect_field_filters(
-            option_prefix="--context",
-            exact=context_exact,
-            contains=context_contains,
-            icontains=context_icontains,
-            regex=context_regex,
-        ),
+    # Build filter mappings from CLI filter options
+    context_filters, context_extra_filters, extra_filters = _build_dump_filters(
+        context_exact=context_exact,
+        context_contains=context_contains,
+        context_icontains=context_icontains,
+        context_regex=context_regex,
+        context_extra_exact=context_extra_exact,
+        context_extra_contains=context_extra_contains,
+        context_extra_icontains=context_extra_icontains,
+        context_extra_regex=context_extra_regex,
+        extra_exact=extra_exact,
+        extra_contains=extra_contains,
+        extra_icontains=extra_icontains,
+        extra_regex=extra_regex,
     )
-    context_extra_filters_map = _none_if_empty(
-        _collect_field_filters(
-            option_prefix="--context-extra",
-            exact=context_extra_exact,
-            contains=context_extra_contains,
-            icontains=context_extra_icontains,
-            regex=context_extra_regex,
-        ),
-    )
-    extra_filters_map = _none_if_empty(
-        _collect_field_filters(
-            option_prefix="--extra",
-            exact=extra_exact,
-            contains=extra_contains,
-            icontains=extra_icontains,
-            regex=extra_regex,
-        ),
+
+    # Resolve format presets from CLI args and context inheritance
+    console_format_preset, console_format_template = _resolve_format_presets(
+        ctx, console_format_preset, console_format_template
     )
-    selected = [name.lower() for name in themes] if themes else list(CONSOLE_STYLE_THEMES.keys())
-    inherited_preset = ctx.obj.get("console_format_preset") if ctx.obj else None
-    inherited_template = ctx.obj.get("console_format_template") if ctx.obj else None
 
-    if console_format_preset is None:
-        console_format_preset = inherited_preset
-    if console_format_template is None:
-        console_format_template = inherited_template
+    # Prepare theme list and dump state
+    selected_themes = [name.lower() for name in themes] if themes else list(CONSOLE_STYLE_THEMES.keys())
     dumps: list[tuple[str, str]] = []
     base_path = dump_path.expanduser() if dump_path is not None else None
     endpoint_tuple = _parse_graylog_endpoint(graylog_endpoint)
 
-    for name in selected:
-        styles = CONSOLE_STYLE_THEMES[name]
-        click.echo(click.style(f"=== Theme: {name} ===", bold=True))
-        for level, style in styles.items():
-            click.echo(f"  {level:<8} -> {style}")
-        click.echo("  emitting sample events…")
+    # Iterate through themes, run demo for each
+    for theme_name in selected_themes:
+        _print_theme_styles(theme_name, CONSOLE_STYLE_THEMES[theme_name])
 
+        # Determine dump target path for this theme
         target_path: Optional[Path] = None
         if dump_format and base_path is not None:
-            target_path = _resolve_dump_path(base_path, name, dump_format)
+            target_path = _resolve_dump_path(base_path, theme_name, dump_format)
             target_path.parent.mkdir(parents=True, exist_ok=True)
 
-        try:
-            result = _logdemo(
-                theme=name,
-                service=service,
-                environment=f"{environment}-{name}" if environment else None,
-                dump_format=dump_format,
-                dump_path=target_path,
-                console_format_preset=console_format_preset,
-                console_format_template=console_format_template,
-                dump_format_preset=dump_format_preset,
-                dump_format_template=dump_format_template,
-                enable_graylog=enable_graylog,
-                graylog_endpoint=endpoint_tuple,
-                graylog_protocol=graylog_protocol,
-                graylog_tls=graylog_tls,
-                enable_journald=enable_journald,
-                enable_eventlog=enable_eventlog,
-                context_filters=context_filters_map,
-                context_extra_filters=context_extra_filters_map,
-                extra_filters=extra_filters_map,
-            )
-        except ValueError as exc:
-            raise click.ClickException(str(exc)) from exc
+        # Run demo for this theme
+        result = _run_theme_demo(
+            theme_name=theme_name,
+            service=service,
+            environment=environment,
+            dump_format=dump_format,
+            target_path=target_path,
+            console_format_preset=console_format_preset,
+            console_format_template=console_format_template,
+            dump_format_preset=dump_format_preset,
+            dump_format_template=dump_format_template,
+            enable_graylog=enable_graylog,
+            graylog_endpoint=endpoint_tuple,
+            graylog_protocol=graylog_protocol,
+            graylog_tls=graylog_tls,
+            enable_journald=enable_journald,
+            enable_eventlog=enable_eventlog,
+            context_filters=context_filters,
+            context_extra_filters=context_extra_filters,
+            extra_filters=extra_filters,
+        )
 
+        # Report results
         events = result["events"]
         click.echo(f"  emitted {len(events)} events")
-        if enable_graylog:
-            destination = endpoint_tuple or ("127.0.0.1", 12201)
-            scheme = graylog_protocol.upper() + ("+TLS" if graylog_tls and graylog_protocol == "tcp" else "")
-            click.echo(f"  graylog -> {destination[0]}:{destination[1]} via {scheme}")
-        if enable_journald:
-            click.echo("  journald -> systemd.journal.send")
-        if enable_eventlog:
-            click.echo("  eventlog -> Windows Event Log")
+        _print_backend_status(
+            enable_graylog=enable_graylog,
+            enable_journald=enable_journald,
+            enable_eventlog=enable_eventlog,
+            endpoint_tuple=endpoint_tuple,
+            graylog_protocol=graylog_protocol,
+            graylog_tls=graylog_tls,
+        )
 
+        # Handle dump output
         if target_path is not None:
             click.echo(f"  dump written to {target_path}")
         elif dump_format and result.get("dump"):
-            dumps.append((name, result["dump"]))
+            dumps.append((theme_name, result["dump"]))
 
         click.echo()
 
+    # Print accumulated dumps to console
     if dump_format and dumps:
-        for name, payload in dumps:
-            click.echo(click.style(f"--- dump ({dump_format}) theme={name} ---", bold=True))
+        for theme_name, payload in dumps:
+            click.echo(click.style(f"--- dump ({dump_format}) theme={theme_name} ---", bold=True))
             click.echo(payload)
             click.echo()
 
diff --git a/src/lib_log_rich/domain/ring_buffer.py b/src/lib_log_rich/domain/ring_buffer.py
index c1f7df9..1548343 100644
--- a/src/lib_log_rich/domain/ring_buffer.py
+++ b/src/lib_log_rich/domain/ring_buffer.py
@@ -18,6 +18,26 @@ Alignment Notes
 ---------------
 The persistence format (newline-delimited JSON) matches the expectations noted
 in ``docs/systemdesign/module_reference.md`` for offline analysis tooling.
+
+Algorithm
+---------
+Uses collections.deque with maxlen for O(1) append and automatic eviction:
+- New events appended to right (most recent)
+- Oldest events automatically evicted from left when capacity reached
+- No manual cleanup needed - deque handles eviction atomically
+
+Thread Safety
+------------
+RingBuffer is NOT thread-safe. Caller (application layer) must ensure
+exclusive access during append operations. Iteration returns a snapshot
+(list) which is safe to use across threads.
+
+Performance Characteristics
+--------------------------
+- Append: O(1) amortized
+- Iteration: O(n) where n = capacity
+- Memory: O(capacity * avg_event_size)
+- Typical capacity: 25,000 events (~50-100MB depending on payload size)
 """
 
 from __future__ import annotations
diff --git a/src/lib_log_rich/lib_log_rich.py b/src/lib_log_rich/lib_log_rich.py
index ef25552..4106356 100644
--- a/src/lib_log_rich/lib_log_rich.py
+++ b/src/lib_log_rich/lib_log_rich.py
@@ -11,6 +11,7 @@ from .runtime import (
     bind,
     dump,
     getLogger,
+    get_minimum_log_level,
     hello_world,
     i_should_fail,
     init,
@@ -30,6 +31,7 @@ __all__ = [
     "bind",
     "dump",
     "getLogger",
+    "get_minimum_log_level",
     "hello_world",
     "i_should_fail",
     "init",
diff --git a/src/lib_log_rich/runtime/__init__.py b/src/lib_log_rich/runtime/__init__.py
index a0a14be..65f36eb 100644
--- a/src/lib_log_rich/runtime/__init__.py
+++ b/src/lib_log_rich/runtime/__init__.py
@@ -44,7 +44,7 @@ from ._settings import (
     RuntimeSettings,
     build_runtime_settings,
 )
-from ._state import LoggingRuntime, clear_runtime, current_runtime, is_initialised
+from ._state import LoggingRuntime, clear_runtime, current_runtime, get_minimum_log_level, is_initialised
 from ._stdlib_handler import StdlibLoggingHandler, attach_std_logging
 
 __all__ = [
@@ -71,6 +71,7 @@ __all__ = [
     "build_runtime_settings",
     "clear_runtime",
     "current_runtime",
+    "get_minimum_log_level",
     "is_initialised",
     "dump",
     "attach_std_logging",
diff --git a/src/lib_log_rich/runtime/_composition.py b/src/lib_log_rich/runtime/_composition.py
index c151564..1ac0a9b 100644
--- a/src/lib_log_rich/runtime/_composition.py
+++ b/src/lib_log_rich/runtime/_composition.py
@@ -345,7 +345,9 @@ def _assemble_runtime(
         environment=settings.environment,
         console_level=ingredients.console_level,
         backend_level=ingredients.backend_level,
+        backend_enabled=len(ingredients.structured_backends) > 0,
         graylog_level=ingredients.graylog_level,
+        graylog_enabled=ingredients.graylog is not None,
         severity_monitor=ingredients.severity_monitor,
         theme=settings.console.theme,
         console_styles=settings.console.styles,
diff --git a/src/lib_log_rich/runtime/_factories.py b/src/lib_log_rich/runtime/_factories.py
index 253d814..88c854b 100644
--- a/src/lib_log_rich/runtime/_factories.py
+++ b/src/lib_log_rich/runtime/_factories.py
@@ -60,6 +60,7 @@ from lib_log_rich.domain import (
 from lib_log_rich.domain.identity import SystemIdentity
 
 from ._settings import ConsoleAppearance, DumpDefaults, FeatureFlags, GraylogSettings, RuntimeSettings
+from .settings.models import DEFAULT_RING_BUFFER_FALLBACK
 
 try:
     import getpass
@@ -449,8 +450,8 @@ def create_ring_buffer(enabled: bool, size: int) -> RingBuffer:
     Why
     ---
     Even when retention is disabled we keep a small buffer for diagnostics (used
-    by the CLI demos). Falling back to 1024 events mirrors the behaviour
-    described in the system design documents.
+    by the CLI demos). Falling back to DEFAULT_RING_BUFFER_FALLBACK events mirrors
+    the behaviour described in the system design documents.
 
     Parameters
     ----------
@@ -472,7 +473,7 @@ def create_ring_buffer(enabled: bool, size: int) -> RingBuffer:
     1024
     """
 
-    capacity = size if enabled else 1024
+    capacity = size if enabled else DEFAULT_RING_BUFFER_FALLBACK
     return RingBuffer(max_events=capacity)
 
 
diff --git a/src/lib_log_rich/runtime/_state.py b/src/lib_log_rich/runtime/_state.py
index 8434b03..dd94018 100644
--- a/src/lib_log_rich/runtime/_state.py
+++ b/src/lib_log_rich/runtime/_state.py
@@ -29,7 +29,9 @@ class LoggingRuntime:
     environment: str
     console_level: LogLevel
     backend_level: LogLevel
+    backend_enabled: bool
     graylog_level: LogLevel
+    graylog_enabled: bool
     severity_monitor: SeverityMonitor
     theme: str | None
     console_styles: Mapping[str, str] | None
@@ -72,6 +74,60 @@ def is_initialised() -> bool:
         return _runtime_state is not None
 
 
+def get_minimum_log_level() -> LogLevel:
+    """Return the minimum (most permissive) log level among all active adapters.
+
+    This convenience function calculates the lowest threshold across
+    ``console_level``, ``backend_level``, and ``graylog_level`` (when Graylog is enabled).
+    It's particularly useful for configuring the stdlib ``logging.Logger`` root logger
+    to ensure no events are filtered before reaching lib_log_rich.
+
+    The function ignores ``graylog_level`` when the Graylog adapter is disabled.
+
+    Returns:
+        LogLevel: The minimum LogLevel among all active adapters.
+                  Lower numeric values represent more permissive levels
+                  (DEBUG=10 < INFO=20 < WARNING=30 < ERROR=40 < CRITICAL=50).
+
+    Raises:
+        RuntimeError: If :func:`lib_log_rich.init` has not been called yet.
+
+    Example:
+        >>> import logging
+        >>> import lib_log_rich as log
+        >>> config = log.RuntimeConfig(
+        ...     service="my-service",
+        ...     environment="dev",
+        ...     console_level="DEBUG",
+        ...     backend_level="INFO",
+        ...     graylog_level="WARNING",
+        ... )
+        >>> log.init(config)
+        >>> # Set stdlib root logger to match the most permissive threshold
+        >>> logging.getLogger().setLevel(log.get_minimum_log_level().to_python_level())
+        >>> logging.getLogger().setLevel(logging.DEBUG)  # Now stdlib won't pre-filter
+        >>> log.shutdown()
+
+    Note:
+        The three log levels (console, backend, Graylog) remain completely independent.
+        This function only provides a convenience view for stdlib integration;
+        it does not change any filtering behavior within lib_log_rich.
+    """
+    runtime = current_runtime()  # Raises RuntimeError if not initialized
+
+    levels = [runtime.console_level]
+
+    # Only include backend_level if any structured backend (journald/eventlog) is enabled
+    if runtime.backend_enabled:
+        levels.append(runtime.backend_level)
+
+    # Only include graylog_level if Graylog adapter is enabled
+    if runtime.graylog_enabled:
+        levels.append(runtime.graylog_level)
+
+    return min(levels, key=lambda lvl: lvl.value)
+
+
 @contextmanager
 def runtime_initialisation() -> Iterator[Callable[[LoggingRuntime], None]]:
     """Yield a setter that installs the runtime atomically."""
@@ -115,6 +171,7 @@ __all__ = [
     "LoggingRuntime",
     "clear_runtime",
     "current_runtime",
+    "get_minimum_log_level",
     "is_initialised",
     "runtime_initialisation",
     "set_runtime",
diff --git a/src/lib_log_rich/runtime/settings/models.py b/src/lib_log_rich/runtime/settings/models.py
index 18931d1..47e41c5 100644
--- a/src/lib_log_rich/runtime/settings/models.py
+++ b/src/lib_log_rich/runtime/settings/models.py
@@ -36,6 +36,25 @@ DEFAULT_SCRUB_PATTERNS: dict[str, str] = {
     "token": r".+",
 }
 
+# PayloadLimits default values
+# These limits protect against unbounded memory growth and ensure predictable performance
+DEFAULT_MESSAGE_MAX_CHARS = 4096  # Maximum message length before truncation
+DEFAULT_EXTRA_MAX_KEYS = 25  # Maximum number of extra fields per event
+DEFAULT_EXTRA_MAX_VALUE_CHARS = 512  # Maximum string length for each extra field value
+DEFAULT_EXTRA_MAX_DEPTH = 3  # Maximum nesting depth for nested extra structures
+DEFAULT_EXTRA_MAX_TOTAL_BYTES = 8192  # Maximum total bytes for all extra fields combined
+DEFAULT_CONTEXT_MAX_KEYS = 20  # Maximum number of context fields per event
+DEFAULT_CONTEXT_MAX_VALUE_CHARS = 256  # Maximum string length for context field values
+DEFAULT_STACKTRACE_MAX_FRAMES = 10  # Maximum stack frames to include in exception traces
+
+# Queue and ring buffer defaults
+# These values balance memory usage against event retention and throughput
+DEFAULT_RING_BUFFER_SIZE = 25_000  # Number of recent events retained in memory for dumps
+DEFAULT_QUEUE_MAXSIZE = 2048  # Maximum queued events before backpressure policies apply
+DEFAULT_QUEUE_PUT_TIMEOUT = 1.0  # Seconds to wait when enqueuing (block policy)
+DEFAULT_QUEUE_STOP_TIMEOUT = 5.0  # Seconds to wait for graceful queue drain on shutdown
+DEFAULT_RING_BUFFER_FALLBACK = 1024  # Fallback ring buffer size when disabled
+
 
 class FeatureFlags(BaseModel):
     """Toggle blocks that influence adapter wiring."""
@@ -134,14 +153,14 @@ class PayloadLimits(BaseModel):
     """Configuration for guarding per-event payload sizes."""
 
     truncate_message: bool = True
-    message_max_chars: int = 4096
-    extra_max_keys: int = 25
-    extra_max_value_chars: int = 512
-    extra_max_depth: int = 3
-    extra_max_total_bytes: int | None = 8192
-    context_max_keys: int = 20
-    context_max_value_chars: int = 256
-    stacktrace_max_frames: int = 10
+    message_max_chars: int = DEFAULT_MESSAGE_MAX_CHARS
+    extra_max_keys: int = DEFAULT_EXTRA_MAX_KEYS
+    extra_max_value_chars: int = DEFAULT_EXTRA_MAX_VALUE_CHARS
+    extra_max_depth: int = DEFAULT_EXTRA_MAX_DEPTH
+    extra_max_total_bytes: int | None = DEFAULT_EXTRA_MAX_TOTAL_BYTES
+    context_max_keys: int = DEFAULT_CONTEXT_MAX_KEYS
+    context_max_value_chars: int = DEFAULT_CONTEXT_MAX_VALUE_CHARS
+    stacktrace_max_frames: int = DEFAULT_STACKTRACE_MAX_FRAMES
 
     model_config = ConfigDict(frozen=True)
 
@@ -178,17 +197,17 @@ class RuntimeConfig(BaseModel):
     graylog_endpoint: tuple[str, int] | None = None
     graylog_level: str | LogLevel = LogLevel.WARNING
     enable_ring_buffer: bool = True
-    ring_buffer_size: int = 25_000
+    ring_buffer_size: int = DEFAULT_RING_BUFFER_SIZE
     enable_journald: bool = False
     enable_eventlog: bool = False
     enable_graylog: bool = False
     graylog_protocol: str = "tcp"
     graylog_tls: bool = False
     queue_enabled: bool = True
-    queue_maxsize: int = 2048
+    queue_maxsize: int = DEFAULT_QUEUE_MAXSIZE
     queue_full_policy: str = "block"
-    queue_put_timeout: float | None = 1.0
-    queue_stop_timeout: float | None = 5.0
+    queue_put_timeout: float | None = DEFAULT_QUEUE_PUT_TIMEOUT
+    queue_stop_timeout: float | None = DEFAULT_QUEUE_STOP_TIMEOUT
     force_color: bool = False
     no_color: bool = False
     console_styles: Mapping[str, str] | Mapping[LogLevel, str] | None = None
@@ -226,9 +245,9 @@ class RuntimeSettings(BaseModel):
     scrub_patterns: dict[str, str] = Field(default_factory=dict)
     diagnostic_hook: DiagnosticHook = None
     console_factory: Callable[["ConsoleAppearance"], ConsolePort] | None = None
-    queue_maxsize: int = 2048
+    queue_maxsize: int = DEFAULT_QUEUE_MAXSIZE
     queue_full_policy: str = Field(default="block")
-    queue_put_timeout: float | None = 1.0
+    queue_put_timeout: float | None = DEFAULT_QUEUE_PUT_TIMEOUT
     queue_stop_timeout: float | None = None
 
     model_config = ConfigDict(frozen=True)
diff --git a/test-write b/test-write
new file mode 100644
index 0000000..e69de29
diff --git a/test-write2 b/test-write2
new file mode 100644
index 0000000..e69de29
diff --git a/tests/runtime/test_runtime_state.py b/tests/runtime/test_runtime_state.py
index c9d996e..e8e70a3 100644
--- a/tests/runtime/test_runtime_state.py
+++ b/tests/runtime/test_runtime_state.py
@@ -11,6 +11,7 @@ from lib_log_rich.runtime._state import (
     LoggingRuntime,
     clear_runtime,
     current_runtime,
+    get_minimum_log_level,
     is_initialised,
     runtime_initialisation,
     set_runtime,
@@ -50,7 +51,9 @@ def _make_runtime(*, service: str = "svc") -> LoggingRuntime:
         environment="test",
         console_level=LogLevel.INFO,
         backend_level=LogLevel.WARNING,
+        backend_enabled=False,
         graylog_level=LogLevel.ERROR,
+        graylog_enabled=False,
         severity_monitor=monitor,
         theme=None,
         console_styles=None,
@@ -105,3 +108,187 @@ def test_runtime_initialisation_rejects_second_install() -> None:
         install(first)
         with pytest.raises(RuntimeError, match=re.escape(_DUPLICATE_ERROR_MESSAGE)):
             install(second)
+
+
+def test_get_minimum_log_level_raises_when_not_initialized() -> None:
+    """get_minimum_log_level() raises RuntimeError before init."""
+    assert is_initialised() is False
+    with pytest.raises(RuntimeError, match="lib_log_rich.init\\(\\) must be called"):
+        get_minimum_log_level()
+
+
+def test_get_minimum_log_level_returns_console_when_lowest() -> None:
+    """Console level is returned when it's the most permissive."""
+    runtime = LoggingRuntime(
+        binder=ContextBinder(),
+        process=lambda **kw: dict(kw),
+        capture_dump=lambda **kw: "",
+        shutdown_async=lambda: None,
+        queue=None,
+        service="svc",
+        environment="test",
+        console_level=LogLevel.DEBUG,
+        backend_level=LogLevel.INFO,
+        backend_enabled=False,
+        graylog_level=LogLevel.WARNING,
+        graylog_enabled=True,
+        severity_monitor=SeverityMonitor(),
+        theme=None,
+        console_styles=None,
+        limits=PayloadLimits(),
+    )
+    set_runtime(runtime)
+
+    assert get_minimum_log_level() == LogLevel.DEBUG
+
+
+def test_get_minimum_log_level_returns_backend_when_lowest() -> None:
+    """Backend level is returned when it's the most permissive."""
+    runtime = LoggingRuntime(
+        binder=ContextBinder(),
+        process=lambda **kw: dict(kw),
+        capture_dump=lambda **kw: "",
+        shutdown_async=lambda: None,
+        queue=None,
+        service="svc",
+        environment="test",
+        console_level=LogLevel.INFO,
+        backend_level=LogLevel.DEBUG,
+        backend_enabled=True,  # Backend (journald/eventlog) is enabled
+        graylog_level=LogLevel.WARNING,
+        graylog_enabled=True,
+        severity_monitor=SeverityMonitor(),
+        theme=None,
+        console_styles=None,
+        limits=PayloadLimits(),
+    )
+    set_runtime(runtime)
+
+    assert get_minimum_log_level() == LogLevel.DEBUG
+
+
+def test_get_minimum_log_level_returns_graylog_when_lowest_and_enabled() -> None:
+    """Graylog level is returned when it's the most permissive and Graylog is enabled."""
+    runtime = LoggingRuntime(
+        binder=ContextBinder(),
+        process=lambda **kw: dict(kw),
+        capture_dump=lambda **kw: "",
+        shutdown_async=lambda: None,
+        queue=None,
+        service="svc",
+        environment="test",
+        console_level=LogLevel.INFO,
+        backend_level=LogLevel.WARNING,
+        backend_enabled=False,
+        graylog_level=LogLevel.DEBUG,
+        graylog_enabled=True,
+        severity_monitor=SeverityMonitor(),
+        theme=None,
+        console_styles=None,
+        limits=PayloadLimits(),
+    )
+    set_runtime(runtime)
+
+    assert get_minimum_log_level() == LogLevel.DEBUG
+
+
+def test_get_minimum_log_level_ignores_graylog_when_disabled() -> None:
+    """Graylog level is ignored when Graylog is disabled."""
+    runtime = LoggingRuntime(
+        binder=ContextBinder(),
+        process=lambda **kw: dict(kw),
+        capture_dump=lambda **kw: "",
+        shutdown_async=lambda: None,
+        queue=None,
+        service="svc",
+        environment="test",
+        console_level=LogLevel.INFO,
+        backend_level=LogLevel.WARNING,
+        backend_enabled=False,
+        graylog_level=LogLevel.DEBUG,  # Would be lowest, but Graylog is disabled
+        graylog_enabled=False,
+        severity_monitor=SeverityMonitor(),
+        theme=None,
+        console_styles=None,
+        limits=PayloadLimits(),
+    )
+    set_runtime(runtime)
+
+    # Should return INFO (console), not DEBUG (disabled Graylog)
+    assert get_minimum_log_level() == LogLevel.INFO
+
+
+def test_get_minimum_log_level_includes_graylog_critical_when_enabled() -> None:
+    """Graylog level CRITICAL is included when Graylog is explicitly enabled."""
+    runtime = LoggingRuntime(
+        binder=ContextBinder(),
+        process=lambda **kw: dict(kw),
+        capture_dump=lambda **kw: "",
+        shutdown_async=lambda: None,
+        queue=None,
+        service="svc",
+        environment="test",
+        console_level=LogLevel.ERROR,
+        backend_level=LogLevel.ERROR,
+        backend_enabled=False,
+        graylog_level=LogLevel.CRITICAL,  # User wants CRITICAL-only Graylog
+        graylog_enabled=True,  # But Graylog IS enabled
+        severity_monitor=SeverityMonitor(),
+        theme=None,
+        console_styles=None,
+        limits=PayloadLimits(),
+    )
+    set_runtime(runtime)
+
+    # Should return ERROR (minimum of console/backend), CRITICAL doesn't affect it
+    assert get_minimum_log_level() == LogLevel.ERROR
+
+
+def test_get_minimum_log_level_with_all_same_level() -> None:
+    """Returns the common level when all three are identical."""
+    runtime = LoggingRuntime(
+        binder=ContextBinder(),
+        process=lambda **kw: dict(kw),
+        capture_dump=lambda **kw: "",
+        shutdown_async=lambda: None,
+        queue=None,
+        service="svc",
+        environment="test",
+        console_level=LogLevel.WARNING,
+        backend_level=LogLevel.WARNING,
+        backend_enabled=False,
+        graylog_level=LogLevel.WARNING,
+        graylog_enabled=True,
+        severity_monitor=SeverityMonitor(),
+        theme=None,
+        console_styles=None,
+        limits=PayloadLimits(),
+    )
+    set_runtime(runtime)
+
+    assert get_minimum_log_level() == LogLevel.WARNING
+
+
+def test_get_minimum_log_level_works_with_mixed_levels() -> None:
+    """Returns the minimum across a mix of levels."""
+    runtime = LoggingRuntime(
+        binder=ContextBinder(),
+        process=lambda **kw: dict(kw),
+        capture_dump=lambda **kw: "",
+        shutdown_async=lambda: None,
+        queue=None,
+        service="svc",
+        environment="test",
+        console_level=LogLevel.ERROR,
+        backend_level=LogLevel.INFO,
+        backend_enabled=True,  # Backend is enabled
+        graylog_level=LogLevel.WARNING,
+        graylog_enabled=True,
+        severity_monitor=SeverityMonitor(),
+        theme=None,
+        console_styles=None,
+        limits=PayloadLimits(),
+    )
+    set_runtime(runtime)
+
+    assert get_minimum_log_level() == LogLevel.INFO
